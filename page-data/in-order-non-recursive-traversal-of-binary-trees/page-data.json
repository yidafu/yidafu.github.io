{"componentChunkName":"component---src-templates-blog-post-js","path":"/in-order-non-recursive-traversal-of-binary-trees/","result":{"data":{"site":{"siteMetadata":{"title":"付达意的博客"}},"markdownRemark":{"id":"a27735f4-c9fd-5cd5-9735-a34206c12336","excerpt":"前话 写孩子-兄弟法表示森林，遇到了用非递归实现中序遍历。先没有参考教材上给的伪 C…","html":"<h1>前话</h1>\n<p>写孩子-兄弟法表示森林，遇到了用非递归实现中序遍历。先没有参考教材上给的伪 C 算法，而是自己独立实现了另一种算法，相比教材的算法，代码量多了一些，操作略微复杂了一点。不管怎么说还是自己独立做出来的。</p>\n<p>实质上，森林的后根遍历就是二叉树的中序遍历。</p>\n<h1>来，上代码</h1>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> Tree<span class=\"token operator\">::</span><span class=\"token function\">_postorderStackTraverse</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">*</span> <span class=\"token operator\">&amp;</span>TNode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> visit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span> ElemType e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    stack<span class=\"token operator\">&lt;</span>Node <span class=\"token operator\">*</span><span class=\"token operator\">></span> Traverse<span class=\"token punctuation\">;</span>\n    Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span> TNode <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span> true <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 入栈操作</span>\n        Node <span class=\"token operator\">*</span>topOne <span class=\"token operator\">=</span> Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>topOne<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            topOne <span class=\"token operator\">=</span> Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">visit</span><span class=\"token punctuation\">(</span>topOne<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>topOne<span class=\"token operator\">-></span>nextSibling<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>topOne<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Traverse<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>topOne<span class=\"token operator\">-></span>childNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1>解释</h1>\n<p>基本思路就是利用栈，森林后根遍历的特点：<strong>孩子应该被先访问，根再被访问，兄弟最后被访问</strong>。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 263px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0b961ef88c4a0b2ad3500fe04bd3f7f5/17741/binary-tree-5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 132.27848101265823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAIAAAA44esqAAAACXBIWXMAAAsTAAALEwEAmpwYAAABv0lEQVQ4y72U266qMBCGff/Ep/AZjIdribcqKEawYI8E5WCDBVpadiJZ+8RSdvba2f9V05kv0z+dmVH7BY2+n4wxSql+hjFGaz0A13WNEOqyf84oy5JS2r//Ba6qCkL4KUwI+S+w1tp8qG1bIcSXKkdRJIRwHOe36A9YSun7PqUUIUQIoZQSQjDGvu8zxrIsm06n3bs+gbXW6/Wacy6ESJ/KsqxpmiAI9vt9URSLxeIdvFqtlFJN00AIgyBgjLVtSwjZ7XZFUcxms5ewUmq73SKEMMb0KUIIY+xwOAAAOOfv4LquAQBxHFNK2YeiKArDMIqiPM/n8/mA5zRNOefX6zWO4yRJyrL0PK/z/K5y51lKqbWmlAZBkOd527YY4z/yvNlswjC8XC4QQoQQhBBj7DjOsGcppeu6AIDz+Rw+FTzlOA5C6H6/D3i2LEtKaYxJ0zRJEs5591W2bQ97tiyraxIAgOd5p9OpaxLbtsuyXC6XA8/GGCOEuk9ijBFCjscjeWoymbzs7VfLQAiR57nruuPx+GXlqqrCMOyP5OPxwBgbY26328vKSql+uLOTpunAPA9qAO6H39+P/s3e/gv4G4bP2cfN6evUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary tree 5\"\n        title=\"binary tree 5\"\n        src=\"/static/0b961ef88c4a0b2ad3500fe04bd3f7f5/17741/binary-tree-5.png\"\n        srcset=\"/static/0b961ef88c4a0b2ad3500fe04bd3f7f5/c26ae/binary-tree-5.png 158w,\n/static/0b961ef88c4a0b2ad3500fe04bd3f7f5/17741/binary-tree-5.png 263w\"\n        sizes=\"(max-width: 263px) 100vw, 263px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>只要将树的节点按照上面的思路放入栈即可。初始时，栈中有一个根元素（先假设有孩子节点和兄弟节点），将根节点取出，依次放入兄弟节点（在栈底最后被访问），根节点，孩子节点（在栈顶最先被访问）。放好以后进入下一个循环，原来的孩子节点成了根节点，重复之前的步骤。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9e66ffcaf4f5bf57e12551bb1921bf9f/c6d67/binary-tree-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.92405063291139%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4klEQVQoz62Sy27EIAxF+f+fzCZBCcgKxOaNQ6VYzVSdVupoejeA5YOvZavxhpQcfGmM0Xt/Gc45p5TGGIj4z3CtNVxqrb0Al1KICADsJSL6KxxCiDG21pgZEYmImc/z/A6XUnLOAkgEEaWstTbGKLYRUWt980puRGSMISKtdQjBe99aK6Ws6+qcu90CgDHGOVdrfcAhhHmeAWCaphijBGutALDvu3QkadKLzFXdDZyfkqf33hgjqcaY4zh+HdXXL8YYKaVt28RwznlZFmvtM69+nD4zx0u9d2aW+s/Lp97Z7Q/qQvyPd2AUfAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary tree 1\"\n        title=\"binary tree 1\"\n        src=\"/static/9e66ffcaf4f5bf57e12551bb1921bf9f/f058b/binary-tree-1.png\"\n        srcset=\"/static/9e66ffcaf4f5bf57e12551bb1921bf9f/c26ae/binary-tree-1.png 158w,\n/static/9e66ffcaf4f5bf57e12551bb1921bf9f/6bdcf/binary-tree-1.png 315w,\n/static/9e66ffcaf4f5bf57e12551bb1921bf9f/f058b/binary-tree-1.png 630w,\n/static/9e66ffcaf4f5bf57e12551bb1921bf9f/c6d67/binary-tree-1.png 734w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c8edfd2978c3cbe614855d5d5f1ced8b/e1031/binary-tree-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.86075949367089%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQoz6WS64rEIAxG+/4vWghRE43VeB22LkPpzg4M8/1TcswhZptfZLseSim11jlnSuljOKWkqnNOEbnVjTHqmd77azjn/B9cawUARIwxfgb33lXVnEkpjTF+4daaPRNCUNVSypzz+vwYAwBERFVzzjFGAFjyP7AxxjlHRMYYZhYRZn729N4jonNu3Tjn9n0nort2jDGEcBzHU7uUIiLWWmZeH7HsluB21fs7XgAgIlXFM4t/PbAb7L1nZiKqtVprETGEcO20vdmB1XzNpvfeWrvZbd+s5wPOK8MC2A31EQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary tree 2\"\n        title=\"binary tree 2\"\n        src=\"/static/c8edfd2978c3cbe614855d5d5f1ced8b/f058b/binary-tree-2.png\"\n        srcset=\"/static/c8edfd2978c3cbe614855d5d5f1ced8b/c26ae/binary-tree-2.png 158w,\n/static/c8edfd2978c3cbe614855d5d5f1ced8b/6bdcf/binary-tree-2.png 315w,\n/static/c8edfd2978c3cbe614855d5d5f1ced8b/f058b/binary-tree-2.png 630w,\n/static/c8edfd2978c3cbe614855d5d5f1ced8b/e1031/binary-tree-2.png 803w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8fa471518744efea5cef6426ea4b5218/9f21b/binary-tree-4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.0253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHUlEQVQoz5WS0Y4CIQxF/f9v1JiYicgwFSjQoRSGTYaN6xqTdc8LD/Ry21sOfafWKiK9dxGptfbPOIwj57yua+89pcTM/xMz8xATUSnluaK1RjujtV/ibduGIQAws9baWjvuRISI7ve7cw4RQwjvxTHG2+0WQpimSSmFiFpr772I5JwBQGudcx7Fb5wvl4tS6nQ6zfPMzCJirT0ej4hIRGnner0+N//jPE2Tc+58Piulaq1hxxgDADHGdV2998YY59wjlO/AiMhaW0oxxlhrW2uICADLssQY2473PqUUQniYH55TrbW21sYUxhhEdM4BwIhw27bxyuuqniGieZ6XZSEiZjbGjCxf0novLqWMxTJzKSXGmFIav+Bv8ed8AUVjvNi3XHRNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary tree 4\"\n        title=\"binary tree 4\"\n        src=\"/static/8fa471518744efea5cef6426ea4b5218/f058b/binary-tree-4.png\"\n        srcset=\"/static/8fa471518744efea5cef6426ea4b5218/c26ae/binary-tree-4.png 158w,\n/static/8fa471518744efea5cef6426ea4b5218/6bdcf/binary-tree-4.png 315w,\n/static/8fa471518744efea5cef6426ea4b5218/f058b/binary-tree-4.png 630w,\n/static/8fa471518744efea5cef6426ea4b5218/9f21b/binary-tree-4.png 706w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>这样已经做到了把二叉树放入栈中，还有一种很重要的问题就是：根节点没有兄弟和孩子节点的情况，这就时候应该退栈了。</p>\n<p>回到之前的放入的步骤，假设根节点的兄弟节点，孩子节点都是<code class=\"language-text\">NULL</code>，我们依旧全部放入栈中，但是，这里就需要在取出栈顶元素的同时，判断取出的元素是否为空，非空就说明当前分支没有走到尽头，就放入其兄弟节点，自己本身，其孩子节点，为空就说明走到了尽头，没有元素可以放入栈中，再次执行出栈操作取出栈中的下一个节点（当前的<code class=\"language-text\">NULL</code>节点的父亲节点），并且访问取出的节点，再依次放入取出的节点的兄弟节点，本身，孩子节点，结束一次循环。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/247d29b33f3fb995df69a3b8dc547b8e/748b0/binary-tree-3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBUlEQVQoz6WS0ZLDIAhF+/8/2bdOYqwaEZAYZGdDp9vZ154nZLxcQG/2BTcz673XWgGgtWZmqmpmc04PHFU9Lj6TNxGptT4vYoy9d0Q0MxHpvXsVPz4ej2VZPPkSE5GqikhKycwQsdY65+y9i4hfYmYi2ve9tUZEx3G8xMx8HEcI4X6/55znnNu2tdb2fWdmMyOidV1ba95CKWVZljHGS6yqYwwA8HqlFGYGgLe4lIKI88K3483/is/zZOac83meiLhtW0rJ3QAghAAAKaUYo5v/zczMIpJzjjGGEFQVEQFgv8g5p5TGGM/nc11XInqv8Fc8xvAl+Tt9Muc8L8zMg//O33ySH/vhSAWHL/GmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary tree 3\"\n        title=\"binary tree 3\"\n        src=\"/static/247d29b33f3fb995df69a3b8dc547b8e/f058b/binary-tree-3.png\"\n        srcset=\"/static/247d29b33f3fb995df69a3b8dc547b8e/c26ae/binary-tree-3.png 158w,\n/static/247d29b33f3fb995df69a3b8dc547b8e/6bdcf/binary-tree-3.png 315w,\n/static/247d29b33f3fb995df69a3b8dc547b8e/f058b/binary-tree-3.png 630w,\n/static/247d29b33f3fb995df69a3b8dc547b8e/748b0/binary-tree-3.png 868w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>如此，便可以做到二叉树的中序遍历。需要注意的一点是：遇到<code class=\"language-text\">NULL</code>节点，再取下栈中一个节点时，要判断一下是否栈为空，为空就结束循环。</p>\n<!-- # 结语\n\n拖了好久，终于补上了这个坑。 -->","frontmatter":{"title":"二叉树的中序非递归遍历","date":"November 17, 2017","description":null}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World"}},"next":{"fields":{"slug":"/separation-in-thousandth/"},"frontmatter":{"title":"数字表示成千位分隔形式的几种解法"}}},"pageContext":{"id":"a27735f4-c9fd-5cd5-9735-a34206c12336","previousPostId":"51052f7a-11e1-5c64-9abf-b544beabd4be","nextPostId":"f72d304f-0e8c-54c1-a2b1-f4968abecfb3"}},"staticQueryHashes":["230163734","3589320610"]}