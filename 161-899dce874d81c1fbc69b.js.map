{"version":3,"sources":["webpack:///./node_modules/prismjs/components/prism-markup-templating.js"],"names":[],"mappings":";;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,YAAY,EAAE;AACjF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,E","file":"161-899dce874d81c1fbc69b.js","sourcesContent":["Prism.languages['markup-templating'] = {};\n\nObject.defineProperties(Prism.languages['markup-templating'], {\n\tbuildPlaceholders: {\n\t\t// Tokenize all inline templating expressions matching placeholderPattern\n\t\t// If the replaceFilter function is provided, it will be called with every match.\n\t\t// If it returns false, the match will not be replaced.\n\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\tif (env.language !== language) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tenv.tokenStack = [];\n\n\t\t\tenv.code = env.code.replace(placeholderPattern, function(match) {\n\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tvar i = env.tokenStack.length;\n\t\t\t\t// Check for existing strings\n\t\t\t\twhile (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1)\n\t\t\t\t\t++i;\n\n\t\t\t\t// Create a sparse array\n\t\t\t\tenv.tokenStack[i] = match;\n\n\t\t\t\treturn '___' + language.toUpperCase() + i + '___';\n\t\t\t});\n\n\t\t\t// Switch the grammar to markup\n\t\t\tenv.grammar = Prism.languages.markup;\n\t\t}\n\t},\n\ttokenizePlaceholders: {\n\t\t// Replace placeholders with proper tokens after tokenizing\n\t\tvalue: function (env, language) {\n\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Switch the grammar back\n\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\tvar j = 0;\n\t\t\tvar keys = Object.keys(env.tokenStack);\n\t\t\tvar walkTokens = function (tokens) {\n\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\n\t\t\t\t\t\tvar index = s.indexOf('___' + language.toUpperCase() + k + '___');\n\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n\t\t\t\t\t\t\tvar after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n\t\t\t\t\t\t\tvar replacement;\n\t\t\t\t\t\t\tif (before || after) {\n\t\t\t\t\t\t\t\treplacement = [before, middle, after].filter(function (v) { return !!v; });\n\t\t\t\t\t\t\t\twalkTokens(replacement);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treplacement = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\tArray.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (token.content && typeof token.content !== 'string') {\n\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twalkTokens(env.tokens);\n\t\t}\n\t}\n});"],"sourceRoot":""}