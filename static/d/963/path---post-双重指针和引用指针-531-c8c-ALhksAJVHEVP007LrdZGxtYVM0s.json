{"data":{"markdownRemark":{"html":"<p> C++双重指针和引用指针</p>\n<h1>引言</h1>\n<p>最近写数据结构遇到了一个有趣问题的问题。</p>\n<pre><code class=\"language-c\">class Tree{\nprivate:\n    Node* root;\npublic:\n    Tree();\n    void create( Node &#x26;TNode );\n}\n\nTree::Tree() {\n    this->root = NULL;\n}\n\nvoid Tree::create( Node &#x26;TNode ) {\n    // 略\n    this->create( TNode->childNode );\n    this->create( TNode->nextSiling );\n}\n\nint main() {\n    Tree test;\n    // 为了简便起见\n    test->create( this->root );\n}\n</code></pre>\n<p>这样写在函数里建树成功了，但是，一返回main()函数所得的树就消失了。在 Stackoverflow 上找到了一个回答里面的文章很好的解释了这个问题。</p>\n<h1>Google 玩家作弊中</h1>\n<p>这里\nTo Be Continue</p>","frontmatter":{"title":"C++双重指针和引用指针"}}},"pageContext":{"slug":"/post/双重指针和引用指针","pre":"/post/C模拟实现类","next":"/post/二叉树的中序非递归遍历","tags":["wabpack","eslint","javascript","axios","api","react","babel","linix","app","algorihm","git","gogs","nginx","proxy","ruby","language","php","shell","cpp","language-feature","c","recursion","java","jsp","mysql","atom","markdown","nodejs","error"]}}