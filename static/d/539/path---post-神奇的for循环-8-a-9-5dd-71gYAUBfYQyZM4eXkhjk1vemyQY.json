{"data":{"markdownRemark":{"html":"<h2>小二先上点茶水</h2>\n<p>猜猜会发生什么：</p>\n<pre><code class=\"language-javascript\">var funcs = [];\n\nfor ( var i = 0 ; i &#x3C; 10 ; i ++ ) {\n    funcs.push( function() {\n        console.log(i);\n    })\n}\n\nfuncs.forEach( function ( func ) {\n    func();\n});\n</code></pre>\n<p><em>例子来自《深入理解ES6》第一章 第8页</em></p>\n<p>这是道 JS 的入（song）门（ming）题。</p>\n<p>打印出来的答案是：</p>\n<p><img src=\"http://image.yidaqiang.cn/blog/js/for-1.png\"></p>\n<p>没想到吧！</p>\n<h2>等等，小二我要的不是啤酒</h2>\n<p>为什么会这样呢？</p>\n<p>这里先解释一下，这段函数干了啥。这段代码主要就是构建了一个函数数组，存放了十个函数。再<code>for-each</code>遍历执行。</p>\n<p><img src=\"http://image.yidaqiang.cn/blog/js/for-2.png\"></p>\n<p>然而在数组里面的函数体却是<code>console.log(i)</code>。这里的<code>i</code>是<code>for ( var i ; i &#x3C; 10 ; i ++)</code>处的引用，可以理解为“这里的<code>i</code>”和<code>for</code>申明的的<code>i</code>是同一个变量。<code>for</code>循环结束<code>i</code>变为<code>10</code>也导致，数组里的每个函数的函数体<code>console.log(i)</code>里的<code>i</code>也都变为了<code>10</code>。</p>\n<p>断点查看一下：</p>\n<p><img src=\"http://image.yidaqiang.cn/blog/js/for-3.png\"></p>\n<p>此时，<code>funcs</code>数组里有的一个函数。控制台执行这个函数。</p>\n<p><img src=\"http://image.yidaqiang.cn/blog/js/for-4.png\"></p>\n<p>这时打印的值不是一开始的 0 ，而是 1 了。</p>\n<p>同理第一个for循环结束以后就变为了 i 变为了 10 ，所有叫 i 的变量都是 10 了。</p>\n<p>代码改成这样大概更好理解：</p>\n<pre><code class=\"language-javascript\">var funcs = [];\n\nvar i;\n\nfor ( i = 0 ; i &#x3C; 10 ; i ++ ) {\n    funcs.push( function() {\n        console.log(i);\n    });\n}\n\nfuncs.forEach( function ( func ) {\n    func();\n});\n</code></pre>\n<p><code>i</code>的声明放到前面，实际上后<code>for-each</code>执行<code>func</code>访问的就是这个变量<code>i</code>。显然，结果的打印 10 次 10。一开始的代码等价于上面的代码。</p>\n<p>究其原因是因为 JS 的<strong>变量提升机制</strong>。这个机制有时很恶心，因为它可以把作用域搞的很乱，你不得不小心翼翼的处理这个问题。上面的例子就是一个典型。</p>\n<h2>来点饮料吧</h2>\n<p>解决方案1：</p>\n<pre><code class=\"language-javascript\">var funcs = [];\n\nvar i;\n\nfor ( i = 0 ; i &#x3C; 10 ; i ++ ) {\n    funcs.push( ( function(value) {\n        return function() {\n            console.log(value);\n        }\n    } ( i ) ) );\n}\n\nfuncs.forEach( function ( func ) {\n    func();\n});\n</code></pre>\n<p>这里同时使用立即执行函数和闭包。</p>\n<p>在 ES6 有更简洁实现方式。</p>\n<p>方案2：</p>\n<pre><code class=\"language-javascript\">var funcs = [];\n\nfor ( let i = 0 ; i &#x3C; 10 ; i ++ ) {\n    funcs.push( function() {\n        console.log(i);\n    });\n}\n\nfuncs.forEach( function ( func ) {\n    func();\n});\n</code></pre>\n<p>这里每次使用<code>let</code>声明，每次循环都会重新创建一个新变量。就不存在 ES5 之前的问题。</p>\n<h2>最后来杯清水</h2>\n<p>ES6 引入了很多新的特性，来解决之前 JS 存在的问题。积极拥抱 ES6 时代的JS。</p>","frontmatter":{"title":"神奇的 for 循环"}}},"pageContext":{"slug":"/post/神奇的for循环","pre":"/post/如何理解递归","next":"/post/糟糕的JS","tags":["wabpack","eslint","javascript","axios","api","react","babel","algorihm","linix","app","git","gogs","ruby","language","nginx","proxy","php","shell","cpp","language-feature","c","recursion","java","jsp","mysql","atom","markdown","nodejs","error"]}}