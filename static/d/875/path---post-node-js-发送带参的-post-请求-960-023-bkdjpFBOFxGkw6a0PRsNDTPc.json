{"data":{"markdownRemark":{"html":"<h1>开头总要有几句话</h1>\n<p>nodeJs 非常容易的可以进行路由分配，发送相应的 HTML 代码。但，实际运用中涉及到了 nodeJS 的另一个主要用途就是做一个中间层。这就要求到了用 nodeJS 做 http 请求。也就是说：前端发送请求到 nodeJS 指定的 URL 地址，nodeJS 在处理这个 URL 时向后端发送一个数据请求，最后把从后端得到的数据做一层渲染或处理。所以，如何在 nodeJS 里发起一个 http 请求呢？</p>\n<!--more-->\n<h1>使用到的方法</h1>\n<p><code>http.request()</code>在 nodeJS 里主要用于发起 http 请求的方法。</p>\n<p>使用时需要传入一个<code>options</code>对象和一个回调函数，返回一个对象 <code>http.clienRequest</code>对象。</p>\n<p>这个返回的对象可以通过进一步事件监听来处理事务逻辑。</p>\n<h2>被坑的地方</h2>\n<p>在网上找了很多的代码，都是在传入的<code>http.request()</code>的回调函数的里监听<code>res</code>对象。我遇到过一个迷之 BUG。昨天，我在这个回调函数用外层的<code>res.send()</code>方法来发送请求，它不行！刚刚试了一下好像又可以了！！它可以了！！！由于年代久远，没有前面的代码对比，这当一个未解之谜吧。</p>\n<p>我在 API 文档里看了半天找到另一种解决方式。把<code>http.request()</code>方茴的对象定义为<code>send</code>(避免变量名重名)。监听<code>send</code>对象的<code>reponse</code>和<code>end</code>事件。</p>\n<h1>小二！上代码</h1>\n<p><strong>外层函数，下面的都是放在这个函数里的</strong></p>\n<pre><code class=\"language-javascript\">var express = require('express');\nvar router = express.Router();\nvar http = require('http');\nvar querystring = require('querystring');\n\nrouter.get('/', function(req, res, next) {\n    // 下面代码放这里\n}\n\nmodule.exports = router;\n</code></pre>\n<p><strong>方案一：</strong></p>\n<pre><code class=\"language-javascript\">var postData = querystring.stringify({\n        jsonList: '这是测试数据6666'\n});\n\n\nvar  options = {\n    hostname: '127.0.0.1',\n    port: 3000,\n    path: '/formSql/insertData',\n    method: 'POST',\n    headers: {\n        'Content-Type':'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n    }\n};\nvar getData = '';\nvar send = http.request(options, function (innerres){\n    innerres.setEncoding('utf8');\n    var data = '';\n    innerres.on('data', function(chunk){\n        data += chunk;\n    });\n    innerres.on('end', function (){\n        res.send(chunk);\n        console.log('响应结束！');\n    });\n});\n\nsend.write(postData + '\\n');\nsend.end();\n</code></pre>\n<p><strong>方案二：</strong></p>\n<pre><code class=\"language-javascript\">var postData = querystring.stringify({\n        jsonList: '这是测试数据8888'\n});\n\nvar  options = {\n    hostname: '127.0.0.1',\n    port: 3000,\n    path: '/formSql/insertData',\n    method: 'POST',\n    headers: {\n        'Content-Type':'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n    }\n};\nvar getData = '';\nvar send = http.request(options);\n\nsend.write(postData + '\\n');\nsend.on('response',function(onres) {\n    console.log('on response');\n    var data = '';\n    onres.on('data',function(chunk) {\n        data  += chunk;\n    });\n    onres.on('end',function() {\n        res.send(data);\n    })\n});\nsend.on('error', function (e) {\n    console.error('请求遇到问题: ' + e.message);\n});\nsend.end();\n</code></pre>","frontmatter":{"title":"nodeJS 发送带参的 POST 请求"}}},"pageContext":{"slug":"/post/nodeJS 发送带参的 POST 请求","pre":"/post/atom-插件推荐-有趣","next":"/post/祭奠服务器再一次炸掉","tags":["wabpack","eslint","javascript","axios","api","react","babel","algorihm","linix","app","git","gogs","ruby","language","nginx","proxy","php","shell","cpp","language-feature","c","recursion","java","jsp","mysql","atom","markdown","nodejs","error"]}}