{"data":{"markdownRemark":{"html":"<h1>一个简单的抽奖例子</h1>\n<p>社团做活动需要一个抽奖的页面，偷懒做了一个简陋版的抽奖页面，太丑了就不放 Github 地址了。</p>\n<p>抽奖本质上就是一个<code>Random()</code>函数的时候，原理上还是不难的。为了方便，先将问题抽象一下。</p>\n<h2>问题抽象</h2>\n<p>先假设有七个人，已经通过数据库查询，或者 API 获得了样例数据：</p>\n<pre><code class=\"language-json\">[\n    {\"name\": \"xiaohong\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaohuang\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaolan\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaolv\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaoqing\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaocheng\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaozi\", \"uuid\": \"xxxxxxxxxxx\"}\n]\n</code></pre>\n<p>规则是：一等奖一个，二等奖两个，三等奖三个。</p>\n<h2>解决思路</h2>\n<h3>指定范围的随机数</h3>\n<p>JS 里面<code>Math.random()</code>返回的是一个<code>[0.1)</code>之间的随机数。</p>\n<p>由此，这里给一种获得指定区间的随机数的方法。</p>\n<pre><code class=\"language-javascript\">/**\n * 这里假设 min max 都是 Int ，且 min &#x3C; max\n * @param  {number} min 返回的最小值\n * @param  {number} max 返回的最大值\n * @return {number}     获得制定范围的随机数，且 [min ,max） ,根据需求预处理为 Int\n */\nfunction godGiveYouLucky(min, max) {\n    return parseInt( Math.random() * (max - min) + min)\n}\n</code></pre>\n<p>更多参见：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random\">Math.random()--MDN</a></p>\n<h3>谁是 LuckyDogs</h3>\n<p>在上面的基础上，想要实现抽取一等奖就已经很容易了。写一个函数，调用上面的成随机函数，由此获得一个中奖者。那二等，三等奖呢？重复调用两次，三次调用中奖函数，代码重复难免过多，写个<code>for</code>循环，但是每次都要写，也很麻烦。出于层次化和封装的考虑，设计两个函数，一个实现从给定的数组里面抽出一个中奖者，另一个就是封装一个<code>for</code>循环。</p>\n<h4>你是 LuckyDog</h4>\n<p>简单想法就是：通过<code>Random()</code>得到一个随机数，这个随机数就是作为抽奖者数组的下标，再根据下标把相应元素取出来，放到一个结果集中，最后把抽奖者数组中的那个元素赋值为<code>undefined</code>，以做标记。这要就得到一个幸运儿。</p>\n<p>具体实现时，这里采用一个递归。</p>\n<pre><code class=\"language-javascript\">function youAraluckyDog(arr) {\n    let luckyNum = godGiveYouLucky(0, arr.length)\n    let luckyDog = arr[luckyNum]\n    if( luckyDog == undefined )\n        return youAraluckyDog(arr)\n    arr[luckyNum] = undefined\n    return luckyDog\n\n}\n</code></pre>\n<p>这里有一个小问题就是如果你传入的数组全是<code>undefined</code>,这个函数就会掉入无限递归调用。由此我们需要添加一个判断条件：当传入的数组不为空的时候，才继续执行，否则返回一个<code>false</code>。</p>\n<pre><code class=\"language-javascript\">function youAraluckyDog(arr) {\n    if(arr.every(val => val == undefined)) return false\n    // 同上\n}\n</code></pre>\n<h4>你们是 LuckyDogs</h4>\n<p>抽出多个中奖者就很容易了。</p>\n<pre><code class=\"language-javascript\">function youAraluckyDogs(count,src) {\n    let reciver = []\n    for (var i = 0; i &#x3C; count; i++) {\n        reciver.push(youAraluckyDog(src))\n    }\n    return reciver\n}\n</code></pre>\n<h2>使用实例</h2>\n<pre><code class=\"language-javascript\">for (var i = 1; i &#x3C; 4; i++) {\n    console.log( youAraluckyDogs(1,arr))\n}\n</code></pre>\n<p>结果：</p>\n<pre><code class=\"language-javascript\">[ { name: 'xiaozi', uuid: 'xxxxxxxxxxx' } ]\n[ { name: 'xiaolv', uuid: 'xxxxxxxxxxx' },\n  { name: 'xiaocheng', uuid: 'xxxxxxxxxxx' } ]\n[ { name: 'xiaoqing', uuid: 'xxxxxxxxxxx' },\n  { name: 'xiaolan', uuid: 'xxxxxxxxxxx' },\n  { name: 'xiaohuang', uuid: 'xxxxxxxxxxx' } ]\n</code></pre>\n<h2>总结</h2>\n<p>基于 JS 自带的随机函数实现一个抽奖，难度不是很大。稍微有点难度在二次或多次抽取中奖者时，可能会出现的重复中奖的问题，对此采取了简化策略，一旦中奖就剔除抽奖队伍，放入中奖者队伍，原位置置空，问题就要就变成了判断某个索引是否为空，是的，再次递归调用该函数。</p>\n<h2>完整代码</h2>\n<pre><code class=\"language-javascript\">var arr = [\n    {\"name\": \"xiaohong\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaohuang\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaolan\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaolv\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaoqing\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaocheng\", \"uuid\": \"xxxxxxxxxxx\"},\n    {\"name\": \"xiaozi\", \"uuid\": \"xxxxxxxxxxx\"}\n]\n\nfunction godGiveYouLucky(from, to) {\n    return parseInt(from + Math.random() * to)\n}\n\nfunction youAraluckyDog(arr) {\n    if( arr.every( val => val == undefined ) ) return false\n\n    let luckyNum = godGiveYouLucky(0, arr.length)\n    let luckyDog = arr[ luckyNum ]\n\n    if( luckyDog == undefined )\n        return youAraluckyDog(arr)\n\n    arr[ luckyNum ] = undefined\n\n    return luckyDog\n\n}\n\nfunction youAraluckyDogs(count,src) {\n    let reciver = []\n\n    for (var i = 0; i &#x3C; count; i++) {\n        reciver.push(youAraluckyDog(src))\n    }\n\n    return reciver\n}\n\nfor (var i = 1; i &#x3C; 4; i++) {\n    console.log( youAraluckyDogs(i,arr))\n}\n</code></pre>","frontmatter":{"title":"webpack配置Reack环境"}}},"pageContext":{"slug":"/post/一个简单的抽奖例子","pre":"/post/webpack配置Reack环境","next":"/post/software-must-install","tags":["wabpack","eslint","javascript","axios","api","react","babel","algorihm","linix","app","git","gogs","ruby","language","nginx","proxy","php","shell","cpp","language-feature","c","recursion","java","jsp","mysql","atom","markdown","nodejs","error"]}}