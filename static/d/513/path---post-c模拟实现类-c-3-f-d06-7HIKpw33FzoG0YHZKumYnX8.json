{"data":{"markdownRemark":{"html":"<h1>由头</h1>\n<p>之前在《深入理解PHP内核》一书中看到了用函数作为结构体的属性，想到用　C　语言来模拟实现面对对象。</p>\n<h2>具体实现</h2>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\ntypedef struct Class {\n    int _param;\n    void ( * _construct )();\n    void ( * function )();\n    void ( * _destory )();\n} Class, *Instance;\n\n\nvoid init( Instance this, int param ) {\n    this->_param = param;\n    printf(\"this is construct function\\n\");\n}\n\nvoid doSomething(Instance this) {\n    printf(\"this is a function called %d\\n\", this->_param);\n}\n\nvoid destory(Instance this) {\n    this->_param = 0;\n    printf(\"this is detory function\\n\");\n}\n\nint main() {\n    struct Class Object = { 233, init, doSomething, destory };\n\n    Object._construct( &#x26;Object, 666 );\n    Object.function(&#x26;Object);\n    Object._destory(&#x26;Object);\n    return 0;\n}\n</code></pre>\n<h2>解释</h2>\n<h3>＂方法＂</h3>\n<p>主要的一个知识点就是 C 语言中，函数是可以已指针的形式被传递（<strong>函数指针</strong>）．</p>\n<p>比如：</p>\n<pre><code class=\"language-c\">int* sort(int arr[], int *compare( int pre, int next ) ) {\n    for( int index = 0; index &#x3C; len(arr) - 1; ++ index ) {\n        if( compare( arr[index], arr[index+1] ) > 0 ) {\n            swap( &#x26;arr[index], &#x26;arr[index+1] );\n        }\n    }\n}\n</code></pre>\n<p>这里就是把一个比较函数<code>compare()</code>传入<code>sort()</code>函数里面．实现了自定义排序过程．这样的做法，动态语言里面比较常见．</p>\n<p>＂模拟类＂也是同样的原理．我们把结构体的属性设为函数指针，结构体通过访问函数指针属性来调用函数，由此来模拟＂方法＂．</p>\n<h3>\"this\"</h3>\n<p>实际上，纯　C 实现＂类＂内部实现<code>this</code>是很不现实的．早期的　C++ 没有底层实现 this 的指向，而是将　C++ 代码编译成　C ，在这个过程中使用了一点小把戏：在编译成　C 代码的过程中，给所有的类的＂方法＂的参数列表添加一个参数，而这个参数就是指向实例的一个指针．</p>\n<h2>总结</h2>\n<p>C 语言，最为强大之处莫过于它的指针了．教材所学，它的一点精髓都没有，同志任需努力呀！</p>","frontmatter":{"title":"C模拟实现类"}}},"pageContext":{"slug":"/post/C模拟实现类","pre":"/post/PHP命令行脚本","next":"/post/二叉树的中序非递归遍历","tags":["wabpack","eslint","javascript","axios","api","react","babel","algorihm","linix","app","git","gogs","ruby","language","nginx","proxy","php","shell","cpp","language-feature","c","recursion","java","jsp","mysql","atom","markdown","nodejs","error"]}}